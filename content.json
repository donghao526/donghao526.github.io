{"pages":[],"posts":[{"title":"Hello World1","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/28/hello-world/"},{"title":"My New Post","text":"Nginx日志切分Nginx Nginx日志切分 最近还是有点累，睡了一天感觉还是略困，这周太忙了，但是很多时候忙到最后，却发现得大于失。感谢周围的同事给我提出的一些建议，还有劝勉，能使我得到些许慰借。为什么想写日志切分，因为一直我好像没有研究过它如何实现，至于如何实现，的确也有多种方法，先写nginx官方推荐的吧。 Nginx官方推荐的日志切分方式Log Rotation:官方推荐的日志切分实现 1234$ mv access.log access.log.0$ kill -USR1 \\`cat master.nginx.pid\\`$ sleep 1$ gzip access.log.0 # do something with access.log.0 原理如下： 将access.log重命名为access.log.0，由于linux都采取文件描述符来读取文件，因此重命名文件后日志还是会持续的向原文件写入 USER1是linux中自定义的信号机制，意思就是说我们可以自己在开发中收到该信号时决定来做什么，nginx在收到该信号时会重新读取配置文件 sleep 1秒能确保nginx将之前的旧日志文件能够彻底的关闭 具体实现设想如果要定时的切分日志，那需要一个定时任务，来定时的对日志文件重命名并且引导nginx写入新的文件，而另一个shell脚本用来做具体的日志切割实现 定时任务如何实现定时任务，有多种多样的solution，为了简单，我就使用mac上的crontab吧， crontab -e添加一行 1 1 /1 * sh ~/logrotation.sh #每一分钟切割一次日志 日志切割脚本12345#! /bin/shtime=\\`date +%Y%m%d%H%m\\`mv access.log access.log.$&#123;time&#125;kill -USR1 \\`ps -ef | grep nginx | grep master |awk &apos;&#123;print $2&#125;&apos;\\` ## 获取nginx的pid，没找到pid文件，就偷懒了sleep 1 执行结果baidudeMacBook-Pro:log echo$ lsaccess.log access.log.201709172136 access.log.201709172137 如上图所示，日志切分成功。 扩展阅读5个使用Redis时需要注意的事项：对于Redis的使用和建议改了一些比较中肯的建议，很实用。 Nginx [ 布隆过滤器 &gt; ]","link":"/2018/03/28/My-New-Post/"}],"tags":[],"categories":[]}