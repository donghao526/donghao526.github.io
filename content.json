{"pages":[],"posts":[{"title":"IO复用之epoll","text":"IO复用select、poll和epoll是三个常用的IO多路复用方法，具体的差别和性能从左到右都是有区别的。但对于这几种IO复用方法是如何使用的，还是一知半解。 实例这几天，通过阅读redis的源码，对epoll的使用方法有了进一步的认识。因此，这里使用epoll做一个简单的接受io请求的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/un.h&gt;#include &lt;sys/time.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;server.cint main(int argc , char *argv[])&#123; int epfd, sfd, new_socket, c, count; struct sockaddr_in server, client; struct epoll_event *events; struct epoll_event ee = &#123;0&#125;; events = (struct epoll_event*)malloc(sizeof(struct epoll_event)*100); //Create socket sfd = socket(AF_INET , SOCK_STREAM , 0); if (sfd == -1) &#123; printf(&quot;Could not create socket&quot;); &#125; server.sin_family = AF_INET; server.sin_addr.s_addr = INADDR_ANY; server.sin_port = htons( 9886); //Bind if( bind(socket_desc, (struct sockaddr *)&amp;server , sizeof(server))) &#123; printf(&quot;failed to bind&quot;); &#125; //Listen listen(sfd, 3); // 设置非阻塞 if (fcntl(socket_desc, F_SETFL, O_NONBLOCK) == -1) &#123; printf(&quot;set non block faild&quot;); &#125; //创建epoll epfd = epoll_create(1024); if (epfd == -1) &#123; printf(&quot;epoll create failed&quot;); &#125; // 为sfd，监听读io ee.events |= EPOLLIN; if (epoll_ctl(epfd, EPOLL_CTL_ADD, sfd, &amp;ee) == -1) &#123; printf(&quot;register failed&quot;); &#125; while(1) &#123; count = epoll_wait(epfd, events, 100,0); if (count &gt; 0) &#123; // 这里其实已经定位到有监听的fd，读io已经就绪，根据count遍历events列表，便可得到实际消息和对应的处理方法 printf(&quot;mo god&quot;); break; &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142client.cint main(int argc, char** argv)&#123; int sockfd, n,rec_len; char recvline[4096], sendline[4096]; char buf[MAXLINE]; char *addr = &quot;127.0.0.1&quot;; struct sockaddr_in servaddr; if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; printf(&quot;create socket error: %s(errno: %d)\\n&quot;, strerror(errno),errno); exit(0); &#125; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9886); if( inet_pton(AF_INET, addr, &amp;servaddr.sin_addr) &lt;= 0)&#123; //inet_pton是Linux下IP地址转换函数，将IP地址在“点分十进制”和“整数”之间转换 printf(&quot;inet_pton error for %s\\n&quot;,argv[1]); exit(0); &#125; if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)&#123; printf(&quot;connect error: %s(errno: %d)\\n&quot;,strerror(errno),errno); exit(0); &#125; printf(&quot;send msg to server: \\n&quot;); fgets(sendline, 4096, stdin); if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0) &#123; printf(&quot;send msg error: %s(errno: %d)\\n&quot;, strerror(errno), errno); exit(0); &#125; if((rec_len = recv(sockfd, buf, MAXLINE,0)) == -1) &#123; perror(&quot;recv error&quot;); exit(1); &#125; buf[rec_len] = &apos;\\0&apos;; printf(&quot;Received : %s &quot;,buf); close(sockfd); exit(0);&#125;","link":"/2020/02/24/epoll/"},{"title":"git 配置","text":"经常使用公司的git仓库，同时也需要使用github，此时git的配置就会出问题。由于git配置的用户名和密码均是全局的，会导致如果使用github的配置如果不指定，就按照公司的git配置中的默认用户名提交。 解决办法，在github仓库中设置local配置 12git config --global user.name 'XXX'git config --global user.email 'XXX'","link":"/2020/04/26/git/"},{"title":"Redis cli处理服务端的返回逻辑","text":"redisGetReply方法 redisGetReply 中的 redisBufferRead 的作用是将数据读取到 redis context 的 reader 中，每个 reader 都包含一个读 buf，pos 和 len 记录了 buf 的长度和读取位置 12345678910111213141516typedef struct redisReader &#123; int err; /* Error flags, 0 when there is no error */ char errstr[128]; /* String representation of error when applicable */ char *buf; /* Read buffer */ size_t pos; /* Buffer cursor */ size_t len; /* Buffer length */ size_t maxbuf; /* Max length of unused buffer */ redisReadTask rstack[9]; // 遍历使用的栈 int ridx; /* Index of current read task */ 标识遍历到哪一层 void *reply; /* Temporary reply pointer */ redisReplyObjectFunctions *fn; void *privdata;&#125; redisReader; buf：读缓冲区 pos：当前读取到的位置 len：buff 的长度 redisReaderGetReply redisReaderGetReply是将reader中保存的数据生成一个reply 1234567891011121314151617181920212223先来看用到的数据结构typedef struct redisReadTask &#123; int type; int elements; /* number of elements in multibulk container */ int idx; /* index in parent (array) object */ void *obj; /* holds user-generated value for a read task */ struct redisReadTask *parent; /* parent task */ void *privdata; /* user-settable arbitrary field */&#125; redisReadTask;/* This is the reply object returned by redisCommand() */typedef struct redisReply &#123; int type; /* REDIS_REPLY_* */ long long integer; /* The integer when type is REDIS_REPLY_INTEGER */ double dval; /* The double when type is REDIS_REPLY_DOUBLE */ size_t len; /* Length of string */ char *str; /* Used for REDIS_REPLY_ERROR, REDIS_REPLY_STRING and REDIS_REPLY_DOUBLE (in additionl to dval). */ char vtype[4]; /* Used for REDIS_REPLY_VERB, contains the null terminated 3 character content type, such as &quot;txt&quot;. */ size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */ struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */&#125; 处理流程 redisReaderGetReply中初始化栈，生成根节点，如下所示 123456789if (r-&gt;ridx == -1) &#123; r-&gt;rstack[0].type = -1; r-&gt;rstack[0].elements = -1; r-&gt;rstack[0].idx = -1; r-&gt;rstack[0].obj = NULL; r-&gt;rstack[0].parent = NULL; r-&gt;rstack[0].privdata = r-&gt;privdata; r-&gt;ridx = 0;&#125; 深度优先遍历所有节点 123while (r-&gt;ridx &gt;= 0) if (processItem(r) != REDIS_OK) break; 返回reply给上层方法 123456789/* Emit a reply when there is one. */if (r-&gt;ridx == -1) &#123; if (reply != NULL) &#123; *reply = r-&gt;reply; &#125; else if (r-&gt;reply != NULL &amp;&amp; r-&gt;fn &amp;&amp; r-&gt;fn-&gt;freeObject) &#123; r-&gt;fn-&gt;freeObject(r-&gt;reply); &#125; r-&gt;reply = NULL;&#125; 关键的processItemprocessItem中对resp协议的每一种元素进行了识别，同时将这些类型划分为三类，分别是：processLineItem、processBulkItem、processAggregateItem。通过以下代码可方便的看出这三种分别对应的数据类型123456789101112131415switch(cur-&gt;type) &#123; case REDIS_REPLY_ERROR: case REDIS_REPLY_STATUS: case REDIS_REPLY_INTEGER: case REDIS_REPLY_DOUBLE: case REDIS_REPLY_NIL: case REDIS_REPLY_BOOL: return processLineItem(r); case REDIS_REPLY_STRING: case REDIS_REPLY_VERB: return processBulkItem(r); case REDIS_REPLY_ARRAY: case REDIS_REPLY_MAP: case REDIS_REPLY_SET: return processAggregateItem(r); processAggregateItemprocessAggregateItem也算直观，如果elements &gt; 0，则将该task节点信息完善，完成该节点对应的reply的obj赋值。同时创建一个新的task，为了进一步的遍历后续节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677static int processAggregateItem(redisReader *r) &#123; redisReadTask *cur = &amp;(r-&gt;rstack[r-&gt;ridx]); void *obj; char *p; long long elements; int root = 0, len; /* Set error for nested multi bulks with depth &gt; 7 */ if (r-&gt;ridx == 8) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;No support for nested multi bulk replies with depth &gt; 7&quot;); return REDIS_ERR; &#125; if ((p = readLine(r,&amp;len)) != NULL) &#123; if (string2ll(p, len, &amp;elements) == REDIS_ERR) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;Bad multi-bulk length&quot;); return REDIS_ERR; &#125; root = (r-&gt;ridx == 0); if (elements &lt; -1 || (LLONG_MAX &gt; SIZE_MAX &amp;&amp; elements &gt; SIZE_MAX)) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;Multi-bulk length out of range&quot;); return REDIS_ERR; &#125; if (elements == -1) &#123; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createNil) obj = r-&gt;fn-&gt;createNil(cur); else obj = (void*)REDIS_REPLY_NIL; if (obj == NULL) &#123; __redisReaderSetErrorOOM(r); return REDIS_ERR; &#125; moveToNextTask(r); &#125; else &#123; if (cur-&gt;type == REDIS_REPLY_MAP) elements *= 2; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createArray) obj = r-&gt;fn-&gt;createArray(cur,elements); else obj = (void*)(long)cur-&gt;type; if (obj == NULL) &#123; __redisReaderSetErrorOOM(r); return REDIS_ERR; &#125; /* Modify task stack when there are more than 0 elements.*/ if (elements &gt; 0) &#123; cur-&gt;elements = elements; cur-&gt;obj = obj; r-&gt;ridx++; r-&gt;rstack[r-&gt;ridx].type = -1; r-&gt;rstack[r-&gt;ridx].elements = -1; r-&gt;rstack[r-&gt;ridx].idx = 0; r-&gt;rstack[r-&gt;ridx].obj = NULL; r-&gt;rstack[r-&gt;ridx].parent = cur; r-&gt;rstack[r-&gt;ridx].privdata = r-&gt;privdata; &#125; else &#123; moveToNextTask(r); &#125; &#125; /* Set reply if this is the root object. */ if (root) r-&gt;reply = obj; return REDIS_OK; &#125; return REDIS_ERR;&#125; processLineItemprocessLineItem比较奇怪，因为创建了obj后一直没有使用它。但是有个细节，我们看下：obj = r-&gt;fn-&gt;createInteger(cur,v)。这说明基于v值创建的对象其实已经绑定到了cur任务中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static int processLineItem(redisReader *r) &#123; redisReadTask *cur = &amp;(r-&gt;rstack[r-&gt;ridx]); void *obj; char *p; int len; if ((p = readLine(r,&amp;len)) != NULL) &#123; if (cur-&gt;type == REDIS_REPLY_INTEGER) &#123; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createInteger) &#123; long long v; if (string2ll(p, len, &amp;v) == REDIS_ERR) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;Bad integer value&quot;); return REDIS_ERR; &#125; obj = r-&gt;fn-&gt;createInteger(cur,v); &#125; else &#123; obj = (void*)REDIS_REPLY_INTEGER; &#125; &#125; else if (cur-&gt;type == REDIS_REPLY_DOUBLE) &#123; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createDouble) &#123; char buf[326], *eptr; double d; if ((size_t)len &gt;= sizeof(buf)) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;Double value is too large&quot;); return REDIS_ERR; &#125; memcpy(buf,p,len); buf[len] = &apos;\\0&apos;; if (strcasecmp(buf,&quot;,inf&quot;) == 0) &#123; d = INFINITY; /* Positive infinite. */ &#125; else if (strcasecmp(buf,&quot;,-inf&quot;) == 0) &#123; d = -INFINITY; /* Nevative infinite. */ &#125; else &#123; d = strtod((char*)buf,&amp;eptr); if (buf[0] == &apos;\\0&apos; || eptr[0] != &apos;\\0&apos; || isnan(d)) &#123; __redisReaderSetError(r,REDIS_ERR_PROTOCOL, &quot;Bad double value&quot;); return REDIS_ERR; &#125; &#125; obj = r-&gt;fn-&gt;createDouble(cur,d,buf,len); &#125; else &#123; obj = (void*)REDIS_REPLY_DOUBLE; &#125; &#125; else if (cur-&gt;type == REDIS_REPLY_NIL) &#123; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createNil) obj = r-&gt;fn-&gt;createNil(cur); else obj = (void*)REDIS_REPLY_NIL; &#125; else if (cur-&gt;type == REDIS_REPLY_BOOL) &#123; int bval = p[0] == &apos;t&apos; || p[0] == &apos;T&apos;; if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createBool) obj = r-&gt;fn-&gt;createBool(cur,bval); else obj = (void*)REDIS_REPLY_BOOL; &#125; else &#123; /* Type will be error or status. */ if (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createString) obj = r-&gt;fn-&gt;createString(cur,p,len); else obj = (void*)(size_t)(cur-&gt;type); &#125; if (obj == NULL) &#123; __redisReaderSetErrorOOM(r); return REDIS_ERR; &#125; /* Set reply if this is the root object. */ if (r-&gt;ridx == 0) r-&gt;reply = obj; moveToNextTask(r); return REDIS_OK; &#125; return REDIS_ERR;&#125; 具体来看下createInteger，发现如果父节点是map、array、set，则将数据放入父节点对象的elements中，如果非结构化对象，则直接返回整数对象，其余line类型的数据也类似。 123456789101112131415161718static void *createIntegerObject(const redisReadTask *task, long long value) &#123; redisReply *r, *parent; r = createReplyObject(REDIS_REPLY_INTEGER); if (r == NULL) return NULL; r-&gt;integer = value; if (task-&gt;parent) &#123; // 如果父节点是map、array、set，则将数据放入父节点对象的elements中 parent = task-&gt;parent-&gt;obj; assert(parent-&gt;type == REDIS_REPLY_ARRAY || parent-&gt;type == REDIS_REPLY_MAP || parent-&gt;type == REDIS_REPLY_SET); parent-&gt;element[task-&gt;idx] = r; &#125; return r;&#125;","link":"/2020/01/07/Redis-get-reply/"},{"title":"Nginx日志切分","text":"为什么想写日志切分，因为一直我好像没有研究过它如何实现，至于如何实现，的确也有多种方法，先写nginx官方推荐的吧。 Nginx官方推荐的日志切分方式 Log Rotation:官方推荐的日志切分实现 1234$ mv access.log access.log.0$ kill -USR1 `cat master.nginx.pid`$ sleep 1$ gzip access.log.0 # do something with access.log.0 原理如下： 将access.log重命名为access.log.0，由于linux都采取文件描述符来读取文件，因此重命名文件后日志还将持续的向原文件写入 USER1是linux中自定义的信号机制，nginx在收到该信号时会重新读取配置文件 sleep 1秒能确保nginx将之前的旧日志文件能够彻底的关闭 具体实现设想如果要定时的切分日志，那需要一个定时任务，来定时的对日志文件重命名并且引导nginx写入新的文件，而另一个shell脚本用来做具体的日志切割实现 定时任务如何实现定时任务，有多种多样的solution，为了简单，我就使用mac上的crontab吧， crontab -e添加一行 1*/1 * * * * sh ~/logrotation.sh #每一分钟切割一次日志 日志切割脚本12345#! /bin/shtime=`date +%Y%m%d%H%m`mv access.log access.log.$&#123;time&#125;kill -USR1 `ps -ef | grep nginx | grep master |awk &apos;&#123;print $2&#125;&apos;` ## 获取nginx的pid，没找到pid文件，就偷懒了sleep 1 执行结果12baidudeMacBook-Pro:log echo$ lsaccess.log access.log.201709172136 access.log.201709172137 如上图所示，日志切分成功。 扩展阅读5个使用Redis时需要注意的事项：对于Redis的使用和建议改了一些比较中肯的建议，很实用。","link":"/2018/03/28/nginx日志切分/"},{"title":"好文共赏吧","text":"好文共赏揭秘！现代IM系统的消息架构如何设计？。之前的IM系统都做的很简单，推拉很难平衡，文中提供了一个新的思路。一个技术人，如何做到比别人更突出。1.做出承诺，超出预期;2.重要不紧急的事如何决定函数的抽象层级https://my.oschina.net/jamesview/blog/2994112","link":"/2019/05/13/mothersday/"},{"title":"redis-cli的实现原理","text":"首先从源码中找入口redis源码：src/redis-cli.c中找到main函数，main函数中核心的处理就是以下部分 12345678910/* Start interactive mode when no command is provided */if (argc == 0 &amp;&amp; !config.eval) &#123; /* Ignore SIGPIPE in interactive mode to force a reconnect */ signal(SIGPIPE, SIG_IGN); /* Note that in repl mode we don't abort on connection error. * A new attempt will be performed for every command send. */ cliConnect(0); repl();&#125; cliConnect主要是与服务端建立连接，每一个连接都会创建一个redisContext结构来保存 replrepl实现了发送命令并输出Server返回结果的主要逻辑 RedisContextredisContext结构如下，重要的字段都进行了注释 12345678910111213141516171819202122typedef struct redisContext &#123; int err; /* Error flags, 0 when there is no error */ char errstr[128]; /* String representation of error when applicable */ int fd; // socket句柄，用户连接redis server int flags; char *obuf; /* Write buffer */ //主要存储发送的命令，resp协议封装后的sds redisReader *reader; /* Protocol reader */ // 存储server返回的数据 enum redisConnectionType connection_type; struct timeval *timeout; struct &#123; char *host; char *source_addr; int port; &#125; tcp; struct &#123; char *path; &#125; unix_sock;&#125; redisContext; repl是做什么的repl其实质就是在不停的重复解析用户输入的命令和redis server返回的参数。repl中，实现这个核心操作的便是issueCommandRepeat方法。 issueCommandRepeat方法我们直观来想，需要做3步操作 从标准输入获取用户输入的命令和参数，并按照resp协议封装 将封装后的数据发送至服务器 读取从服务器返回的结果并解析输出 cli如何封装输入的命令和参数通过对issueCommandRepeat方法的分析，极其对它里边调用关系的梳理，发现是redisAppendCommandArgv处理命令并将命令写入context的obuf中，redisAppendCommandArgv的调用层级和源码如下12345678910111213141516171819202122232425issueCommandRepeat cliSendCommand redisAppendCommandArgv redisFormatSdsCommandArgv __redisAppendCommand源码： sds cmd; int len; //redisFormatSdsCommandArgv是将命令极其跟随的参数，使用resp协议封装后，存到一个sds结构中。 len = redisFormatSdsCommandArgv(&amp;cmd,argc,argv,argvlen); if (len == -1) &#123; __redisSetError(c,REDIS_ERR_OOM,&quot;Out of memory&quot;); return REDIS_ERR; &#125; //__redisAppendCommand是将sds保存的resp协议的数据存到redisContext中的obuf中 if (__redisAppendCommand(c,cmd,len) != REDIS_OK) &#123; sdsfree(cmd); return REDIS_ERR; &#125; // 释放sds结构申请的内存 sdsfree(cmd); return REDIS_OK; 向服务器发送命令有了封装好的数据，下一步就是可以向服务器发送命令了，还是issueCommandRepeat方法，看下述代码1234567891011121314151617181920212223242526272829303132333435363738while(repeat-- &gt; 0) &#123; redisAppendCommandArgv(context,argc,(const char**)argv,argvlen); while (config.monitor_mode) &#123; if (cliReadReply(output_raw) != REDIS_OK) exit(1); fflush(stdout); &#125; if (config.pubsub_mode) &#123; if (config.output != OUTPUT_RAW) printf(&quot;Reading messages... (press Ctrl-C to quit)\\n&quot;); while (1) &#123; if (cliReadReply(output_raw) != REDIS_OK) exit(1); &#125; &#125; if (config.slave_mode) &#123; printf(&quot;Entering replica output mode... (press Ctrl-C to quit)\\n&quot;); slaveMode(); config.slave_mode = 0; zfree(argvlen); return REDIS_ERR; /* Error = slaveMode lost connection to master */ &#125; if (cliReadReply(output_raw) != REDIS_OK) &#123; zfree(argvlen); return REDIS_ERR; &#125; else &#123; /* Store database number when SELECT was successfully executed. */ if (!strcasecmp(command,&quot;select&quot;) &amp;&amp; argc == 2 &amp;&amp; config.last_cmd_type != REDIS_REPLY_ERROR) &#123; config.dbnum = atoi(argv[1]); cliRefreshPrompt(); &#125; else if (!strcasecmp(command,&quot;auth&quot;) &amp;&amp; argc == 2) &#123; cliSelect(); &#125; &#125; if (config.interval) usleep(config.interval); fflush(stdout); /* Make it grep friendly */ &#125; 我们知道redisAppendCommandArgv只是组装了命令，并没有发送，cliReadReply看样子是将结果读取，最后fflush是将结果输出到标准输出。那么发送命令只可能藏在cliReadReply中，继续分析cliReadyReply 12cliReadyReply redisGetReply 在redisGetReply中发现特别隐藏的redisBufferWrite，这个实际是发送了请求，我们看具体代码1234567891011121314151617181920if (sdslen(c-&gt;obuf) &gt; 0) &#123; // 发送命令 nwritten = write(c-&gt;fd,c-&gt;obuf,sdslen(c-&gt;obuf)); if (nwritten == -1) &#123; if ((errno == EAGAIN &amp;&amp; !(c-&gt;flags &amp; REDIS_BLOCK)) || (errno == EINTR)) &#123; /* Try again later */ &#125; else &#123; __redisSetError(c,REDIS_ERR_IO,NULL); return REDIS_ERR; &#125; &#125; else if (nwritten &gt; 0) &#123; // 发送成功，清理obuf if (nwritten == (signed)sdslen(c-&gt;obuf)) &#123; sdsfree(c-&gt;obuf); c-&gt;obuf = sdsempty(); &#125; else &#123; sdsrange(c-&gt;obuf,nwritten,-1); &#125; &#125;&#125; 读取服务器返回的结果继续在redisGetReply读代码，能够看到redisBufferRead是获取服务器返回的数据的方法。12345678910111213141516171819202122232425262728int redisBufferRead(redisContext *c) &#123; char buf[1024*16]; int nread; /* Return early when the context has seen an error. */ if (c-&gt;err) return REDIS_ERR; // 从fd读取数据 nread = read(c-&gt;fd,buf,sizeof(buf)); if (nread == -1) &#123; if ((errno == EAGAIN &amp;&amp; !(c-&gt;flags &amp; REDIS_BLOCK)) || (errno == EINTR)) &#123; /* Try again later */ &#125; else &#123; __redisSetError(c,REDIS_ERR_IO,NULL); return REDIS_ERR; &#125; &#125; else if (nread == 0) &#123; __redisSetError(c,REDIS_ERR_EOF,&quot;Server closed the connection&quot;); return REDIS_ERR; &#125; else &#123; if (redisReaderFeed(c-&gt;reader,buf,nread) != REDIS_OK) &#123; __redisSetError(c,c-&gt;reader-&gt;err,c-&gt;reader-&gt;errstr); return REDIS_ERR; &#125; &#125; return REDIS_OK;&#125; 从代码可以看到如果读取成功会调用redisReaderFeed将buf内容写入到redisContext中的reader里对应的buf中 redisGetReply中，又调用了redisGetReplyFromReader，redisReaderGetReply将返回的数据通过resp协议解析为字符串1234567int redisGetReplyFromReader(redisContext *c, void **reply) &#123; if (redisReaderGetReply(c-&gt;reader,reply) == REDIS_ERR) &#123; __redisSetError(c,c-&gt;reader-&gt;err,c-&gt;reader-&gt;errstr); return REDIS_ERR; &#125; return REDIS_OK;&#125; 最终结果的输出最终结果的输出还是在cliReadReply中。将数据存储在字符串中，通过fwrite写入标准输出中，再返回到cliSendCommand中fflush后输出到终端","link":"/2019/11/29/redis-cli/"},{"title":"布隆过滤器","text":"布隆过滤器一种空间数据结构，用来判断一个元素是否在某个集合中。由于具有假阳性，所以布隆过滤器只能得出某个元素有可能在该集合，反之该元素一定不在这个集合中。 布隆过滤器简介一个空的布隆过滤器是一个m位均为0的比特位数组，同时定义了k个哈希函数，将某个元素得出的哈希值映射到m个比特位中的某一位，将该为置为1，生成一个随机的分布。通常k要远远小于m，k和m的选取取决于过滤器的假阳性概率。 添加元素当给布隆过滤器中添加一个元素时，利用k个哈希函数得出k个位置，并将$m$个比特位中对应的k个位置设置为1。 查询元素查询元素时同样计算出k个位置，并获取该$k$个位置的所有元素值，当有一个位为0的话，就证明该元素不在该集合里。若k个位置均为1，则表示该元素可能在集合里，因为某些为1的位可能是别的元素在插入时设置的。 删除元素由于假阳性的引入，布隆过滤器是不能删除元素的。 布隆过滤器的优点链表、哈希表和平衡二叉树都能够做元素的查找，但是布隆过滤器明显在时间和空间利用率上更优 空间利用率一个拥有1%的错误率和一个优化后的$k$的布隆过滤器，存储一个元素只需要9.6bit，没降低1%的错误率每个元素也只需增加4.8bit [文章中写的结论，还需要看证明过程] 时间复杂度时间复杂度显然是$O(k)$ 假阳性的概率假定一个哈希函数选择每个插入位置的概率都是相等的，且位数组一共m位，那么某个比特位被hash函数设为1的概率为$$ 1 - \\frac{1}{m}$$那么通过计算k个哈希函数后，该位被置为1的概率为$$ ( 1 - \\frac{1}{m} )^k$$如果该过滤器有n个元素，那么该位为0的概率为$$ ( 1 - \\frac{1}{m} )^{kn}$$该位为1的概率为$$ 1- ( 1 - \\frac{1}{m} )^kn$$那么随便找k个位置，这些位置都为1的概率(也可认为是假阳性概率)为$$ (1- ( 1 - \\frac{1}{m} )^{kn})^k \\approx (1 - e^{-kn/m})^k$$需要注意的是，该概率不是严格准确的，因为$k$个为在被置1时，不是独立事件，但是概率大约是相似的。由此可见，假阳性的概率随着比特位数组长度$m$的增大而减小，随着集合元素$n的增大而增大。那么证明了如果$m$足够大，布隆过滤器的准确性还是很高的。 如何寻找最适合的k最适合的$k$就是能够使过滤器假阳性的概率达到最低，直观来讲增加哈希函数可以提升准确率，但是又会影响更多的比特位，所以随着哈希函数数量k的增加，假阳性概率或许增加或许减少，因此怎么算最适合的k呢。我们拿出上述得到的概率，假定假阳性概率为f $$ f = (1 - e^{-kn/m})^k$$为了简化运算对$f$取对数$$ g = ln(f) = k(1 - e^{-kn/m})$$对其进行求导$$\\frac{dg}{dk} = ln(1 - e^{-kn/m}) + \\frac{kn}{m} \\frac{e^{-kn/m}}{1 - e^{-kn/m}}$$当导数为0的时候，就是最适合的k，我们得出最适合的k如下:$$ k = \\frac{m}{n}ln(2) $$ 元素数量估算Swamidass &amp; Baldi提出了布隆过滤器中实际元素估算的方式$$ n^* = - \\frac{m}{k} ln [1-\\frac{X}{k}] $$ 其中，$$ n$*为元素个数的近似值，m是位数组长度，k是哈希函数的数量, $X$是位数组中被置为1的位的数量。还没有看完证明过程 总结布隆过滤器由于引入了假阳性，因此不太适合高精度的需求，业务场景需要能够接受一定错误容忍度，但是查询和插入都是$O(k)$的时间复杂度，空间复杂度也相当可观，因此在快速的元素查找定位场景还是大有裨益的。 参考文献Bloom_filterNotes 10 for CS 170Mathematical Correction for Fingerprint Similarity Measures to Improve Chemical Retrieval","link":"/2019/03/28/布隆过滤器/"},{"title":"坚持就会更加坚定","text":"距离泰山马拉松结束已经两周了，这半年来的坚持，总算还是有些许收获。 希望自己不负青春，加油养成自律、坚定的好习惯。","link":"/2019/11/11/running/"},{"title":"redis-server","text":"首先在initServer中，注册eventloop，为io复用做准备 12server.cserver.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); ListenToPort创建基于tcp的socket连接，并监听客户端连接，并将该socket设置为非阻塞 12345server.c/* Open the TCP listening socket for the user commands. */if (server.port != 0 &amp;&amp; listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR) exit(1); 为每个server的fd设置可读事件回调 12345for (j = 0; j &lt; server.ipfd_count; j++) &#123; if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) &#123; serverPanic(&quot;Unrecoverable error creating server.ipfd file event.&quot;); &#125;&#125; aeCreateFileEvent 123456789101112131415161718192021222324252627282930313233343536ae.ctypedef struct aeFileEvent &#123; int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */ aeFileProc *rfileProc; aeFileProc *wfileProc; void *clientData;&#125; aeFileEvent;int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)&#123; if (fd &gt;= eventLoop-&gt;setsize) &#123; errno = ERANGE; return AE_ERR; &#125; // 获取对应server socket fd对应的event aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; // 把fd写入eventloop的state里 if (aeApiAddEvent(eventLoop, fd, mask) == -1) return AE_ERR; // 设置该fd对应event的读状态或写状态 fe-&gt;mask |= mask; // 注册读写处理的回调函数proc if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc; if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc; // 存储数据 fe-&gt;clientData = clientData; // 更新eventloop的最大fd if (fd &gt; eventLoop-&gt;maxfd) eventLoop-&gt;maxfd = fd; return AE_OK;&#125; 再来看看acceptTcpHandler 1234567891011121314151617181920void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) &#123; int cport, cfd, max = MAX_ACCEPTS_PER_CALL; char cip[NET_IP_STR_LEN]; UNUSED(el); UNUSED(mask); UNUSED(privdata); while(max--) &#123; 对于每个server的fd，accept一个客户端fd，封装了普通的accept cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport); if (cfd == ANET_ERR) &#123; if (errno != EWOULDBLOCK) serverLog(LL_WARNING, &quot;Accepting client connection: %s&quot;, server.neterr); return; &#125; serverLog(LL_VERBOSE,&quot;Accepted %s:%d&quot;, cip, cport); acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip); &#125;&#125; acceptCommonHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void acceptCommonHandler(connection *conn, int flags, char *ip) &#123; client *c; UNUSED(ip); /* Admission control will happen before a client is created and connAccept() * called, because we don&apos;t want to even start transport-level negotiation * if rejected. */ if (listLength(server.clients) &gt;= server.maxclients) &#123; char *err = &quot;-ERR max number of clients reached\\r\\n&quot;; /* That&apos;s a best effort error message, don&apos;t check write errors. * Note that for TLS connections, no handshake was done yet so nothing is written * and the connection will just drop. */ if (connWrite(conn,err,strlen(err)) == -1) &#123; /* Nothing to do, Just to avoid the warning... */ &#125; server.stat_rejected_conn++; connClose(conn); return; &#125; /* Create connection and client */ // 创建客户端，设置该fd非阻塞，并且设置读函数readQueryFromClient if ((c = createClient(conn)) == NULL) &#123; char conninfo[100]; serverLog(LL_WARNING, &quot;Error registering fd event for the new client: %s (conn: %s)&quot;, connGetLastError(conn), connGetInfo(conn, conninfo, sizeof(conninfo))); connClose(conn); /* May be already closed, just ignore errors */ return; &#125; /* Last chance to keep flags */ c-&gt;flags |= flags; /* Initiate accept. * * Note that connAccept() is free to do two things here: * 1. Call clientAcceptHandler() immediately; * 2. Schedule a future call to clientAcceptHandler(). * * Because of that, we must do nothing else afterwards. */ if (connAccept(conn, clientAcceptHandler) == C_ERR) &#123; char conninfo[100]; serverLog(LL_WARNING, &quot;Error accepting a client connection: %s (conn: %s)&quot;, connGetLastError(conn), connGetInfo(conn, conninfo, sizeof(conninfo))); freeClient(connGetPrivateData(conn)); return; &#125;&#125; redis的eventloop在哪 -&gt; aeMain`","link":"/2020/02/19/redis-server/"},{"title":"走出舒适区","text":"说来惭愧，上一次更新已经三个月了，这三个月发生了很多，但自己始终没有成长，加油，make change！","link":"/2019/08/22/走出舒适区/"},{"title":"小长假","text":"千万不要在小长假出行，人实在太多，看来灭霸是有些道理的","link":"/2019/05/05/shinian/"}],"tags":[{"name":"IO复用","slug":"IO复用","link":"/tags/IO复用/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"run","slug":"run","link":"/tags/run/"},{"name":"生活","slug":"生活","link":"/tags/生活/"}],"categories":[]}